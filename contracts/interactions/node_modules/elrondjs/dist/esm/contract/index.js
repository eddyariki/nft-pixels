var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Buffer } from 'buffer';
import { BigVal } from 'bigval';
import { ContractQueryResultDataType, } from '../common';
import { TransactionOptionsBase, joinDataArguments, TransactionBuilder, verifyTransactionOptions, ADDRESS_ZERO_BECH32, ARWEN_VIRTUAL_MACHINE, addressToHexString, keccak, hexStringToAddress, contractMetadataToString, stringToHex, numberToHex, queryResultValueToString, queryResultValueToHex } from '../lib';
/**
 * Parse a contract query result.
 *
 * @param result The query result.
 * @param options Parsing options.
 */
export const parseQueryResult = (result, options) => {
    options.index = options.index || 0;
    const inputVal = result.returnData[options.index];
    switch (options.type) {
        case ContractQueryResultDataType.BOOLEAN: {
            if (!inputVal) {
                return false;
            }
            else {
                return queryResultValueToHex(inputVal) === '01';
            }
        }
        case ContractQueryResultDataType.BIG_INT:
        case ContractQueryResultDataType.INT: {
            let ret;
            if (!inputVal) {
                ret = new BigVal(0);
            }
            else {
                ret = new BigVal(`0x${queryResultValueToHex(inputVal)}`);
            }
            return (options.type === ContractQueryResultDataType.INT ? ret.toNumber() : ret);
        }
        case ContractQueryResultDataType.ADDRESS: {
            return hexStringToAddress(queryResultValueToHex(inputVal));
        }
        case ContractQueryResultDataType.HEX: {
            if (!inputVal) {
                return '0x0';
            }
            else {
                return queryResultValueToHex(inputVal);
            }
        }
        default: {
            return queryResultValueToString(inputVal);
        }
    }
};
/**
 * Builder for contract deployment transactions.
 */
class ContractDeploymentBuilder extends TransactionBuilder {
    /**
     * Constructor.
     *
     * @param code Contract bytecode.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Transaction options.
     */
    constructor(code, metadata, initArgs, options) {
        super(options);
        this._code = code;
        this._metadata = metadata;
        this._initArgs = initArgs;
    }
    getTransactionDataString() {
        const metadata = contractMetadataToString(this._metadata);
        return joinDataArguments(this._code.toString('hex'), ARWEN_VIRTUAL_MACHINE, metadata, ...this._initArgs);
    }
    getReceiverAddress() {
        return ADDRESS_ZERO_BECH32;
    }
}
/**
 * Builder for contract upgrade transactions.
 */
class ContractUpgradeBuilder extends TransactionBuilder {
    /**
     * Constructor.
     *
     * @param code Contract bytecode.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Transaction options.
     */
    constructor(address, code, metadata, initArgs, options) {
        super(options);
        this._address = address;
        this._code = code;
        this._metadata = metadata;
        this._initArgs = initArgs;
    }
    getTransactionDataString() {
        const metadata = contractMetadataToString(this._metadata);
        return joinDataArguments('upgradeContract', this._code.toString('hex'), metadata, ...this._initArgs);
    }
    getReceiverAddress() {
        return this._address;
    }
}
/**
 * Builder for contract invocation transactions.
 */
class ContractInvocationBuilder extends TransactionBuilder {
    /**
     * Constructor.
     *
     * @param address Contract address.
     * @param func Function to call.
     * @param args Arguments to pass to function.
     * @param options Transaction options.
     */
    constructor(address, func, args, options) {
        super(options);
        this._address = address;
        this._func = func;
        this._args = args;
    }
    getTransactionDataString() {
        let args = [];
        // check if we should transfer a token along with this call!
        if (this._options) {
            const { esdt } = this._options;
            if (esdt) {
                args = [
                    'ESDTTransfer',
                    stringToHex(esdt.id),
                    numberToHex(esdt.value),
                    stringToHex(this._func),
                    ...this._args
                ];
            }
        }
        // if not yet set then it's just a standard function call
        if (!args.length) {
            args = [this._func, ...this._args];
        }
        return joinDataArguments(...args);
    }
    getReceiverAddress() {
        return this._address;
    }
}
/**
 * Interfaces for working with contracts.
 */
export class Contract extends TransactionOptionsBase {
    /**
     * Constructor.
     *
     * @param address Contract address.
     * @param options Transaction options.
     */
    constructor(address, options) {
        super(options);
        this._address = '';
        this._address = address;
    }
    /**
     * Get contract address.
     */
    get address() {
        return this._address;
    }
    /**
     * Get instance for contract at given address.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * If `options.provider` is set then this checks to ensure that contract code is present at the
     * given address.
     *
     * @param address Contract address.
     * @param options Base options for all subsequent transactions and contract querying.
     */
    static at(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // if provider is given then confirm that address contains code!
            if (options === null || options === void 0 ? void 0 : options.provider) {
                try {
                    const { code } = yield options.provider.getAddress(address);
                    if (!code) {
                        throw new Error('No code found at address');
                    }
                }
                catch (err) {
                    throw new Error(`Error checking for contract code: ${err.message}`);
                }
            }
            return new Contract(address, options);
        });
    }
    /**
     * Deploy a contract.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param code Contract bytecode code.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Base options for all subsequent transactions and contract querying.
     */
    static deploy(code, metadata, initArgs, options) {
        return __awaiter(this, void 0, void 0, function* () {
            verifyTransactionOptions(options, 'provider', 'signer', 'sender');
            const { provider, sender, signer } = options;
            // compute deployed address
            const computedAddress = yield Contract.computeDeployedAddress(sender, options.provider);
            // create deployment transaction
            const obj = Contract.createDeployment(code, metadata, initArgs, options);
            const tx = yield obj.toTransaction();
            // sign and send
            const signedTx = yield signer.signTransaction(tx, provider);
            const hash = yield provider.sendSignedTransaction(signedTx);
            const receipt = yield provider.waitForTransaction(hash);
            return Object.assign(Object.assign({}, receipt), { contract: new Contract(computedAddress, Object.assign(Object.assign({}, options), { gasLimit: undefined })) });
        });
    }
    /**
     * Compute the would-be address of a deployed contract.
     *
     * The address is computed deterministically, from the address of the deployer and their next transaction nonce.
     *
     * @param deployer Address of contract deployer/owner in bech32 format.
     * @param provider Provider instance.
     */
    static computeDeployedAddress(deployer, provider) {
        return __awaiter(this, void 0, void 0, function* () {
            const { nonce } = yield provider.getAddress(deployer);
            return Contract.computeDeployedAddressWithNonce(deployer, nonce);
        });
    }
    /**
     * Compute the would-be address of a deployed contract.
     *
     * The address is computed deterministically, from the address of the deployer and the given transaction nonce.
     *
     * Based on: https://github.com/ElrondNetwork/elrond-sdk/blob/master/erdjs/src/smartcontracts/smartContract.ts#L216
     *
     * @param deployer Address of contract deployer/owner in bech32 format.
     * @param nonce Their nonce at the time of deployment.
     */
    static computeDeployedAddressWithNonce(deployer, nonce) {
        return __awaiter(this, void 0, void 0, function* () {
            const initialPadding = Buffer.alloc(8, 0);
            const ownerPubkey = Buffer.from(addressToHexString(deployer), 'hex');
            const shardSelector = ownerPubkey.slice(30);
            const ownerNonceBytes = Buffer.alloc(8);
            ownerNonceBytes.writeBigUInt64LE(BigInt(nonce.valueOf()));
            const bytesToHash = Buffer.concat([ownerPubkey, ownerNonceBytes]);
            const hash = keccak(bytesToHash);
            const vmTypeBytes = Buffer.from(ARWEN_VIRTUAL_MACHINE, 'hex');
            const addressBytes = Buffer.concat([
                initialPadding,
                vmTypeBytes,
                hash.slice(10, 30),
                shardSelector
            ]);
            return hexStringToAddress(addressBytes.toString('hex'));
        });
    }
    /**
     * Create a contract deployment transaction.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param code Contract bytecode code.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Transaction options.
     */
    static createDeployment(code, metadata, initArgs, options) {
        verifyTransactionOptions(options, 'provider');
        return new ContractDeploymentBuilder(code, metadata, initArgs, options);
    }
    /**
     * Create a contract upgrade transaction.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param address Contract address.
     * @param code Contract bytecode code.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Transaction options.
     */
    static createUpgrade(address, code, metadata, initArgs, options) {
        verifyTransactionOptions(options, 'provider');
        return new ContractUpgradeBuilder(address, code, metadata, initArgs, options);
    }
    /**
     * Construct a contract function invocation transaction.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param address Contract address.
     * @param func Function to call.
     * @param args Arguments to pass to function.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    static createInvocation(address, func, args, options) {
        verifyTransactionOptions(options, 'provider');
        return new ContractInvocationBuilder(address, func, args, options);
    }
    /**
     * Query a function in read-only mode, without using a transaction.
     *
     * This will call the given contract function in read-only mode, i.e. without using a transaction.
     *
     * @param func Function to call.
     * @param args Arguments to pass to function.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    query(func, args, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const mergedOptions = this._mergeTransactionOptions(options, 'provider');
            return yield mergedOptions.provider.queryContract({
                contractAddress: this._address,
                functionName: func,
                args: args || [],
                caller: mergedOptions.sender,
                value: mergedOptions.value,
            });
        });
    }
    /**
     * Invoke a function using a transaction.
     *
     * @param func Function to call.
     * @param args Arguments to pass to function.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    invoke(func, args, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const mergedOptions = this._mergeTransactionOptions(options, 'signer', 'provider');
            const obj = Contract.createInvocation(this._address, func, args || [], mergedOptions);
            const tx = yield obj.toTransaction();
            const signedTx = yield mergedOptions.signer.signTransaction(tx, mergedOptions.provider);
            const hash = yield mergedOptions.provider.sendSignedTransaction(signedTx);
            return mergedOptions.provider.waitForTransaction(hash);
        });
    }
    /**
     * Upgrade the contract code and metadata.
     *
     * @param code New code.
     * @param metadata New metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    upgrade(code, metadata, initArgs, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const mergedOptions = this._mergeTransactionOptions(options, 'signer', 'provider');
            const obj = Contract.createUpgrade(this._address, code, metadata, initArgs, mergedOptions);
            const tx = yield obj.toTransaction();
            const signedTx = yield mergedOptions.signer.signTransaction(tx, mergedOptions.provider);
            const hash = yield mergedOptions.provider.sendSignedTransaction(signedTx);
            return mergedOptions.provider.waitForTransaction(hash);
        });
    }
}
