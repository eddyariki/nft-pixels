/// <reference types="node" />
import { BigVal } from 'bigval';
import { ContractQueryResult, ContractQueryResultParseOptions, TransactionOptions, TransactionReceipt, Provider, ContractMetadata } from '../common';
import { TransactionOptionsBase, TransactionBuilder } from '../lib';
/**
 * Receipt obtained when deploying a contract.
 */
export interface ContractDeploymentTransactionReceipt extends TransactionReceipt {
    /**
     * Contract instance for interacting with the deployed contract.
     *
     * This is only useful if the deployment transaction succeeds.
     */
    contract: Contract;
}
/**
 * Parse a contract query result.
 *
 * @param result The query result.
 * @param options Parsing options.
 */
export declare const parseQueryResult: (result: ContractQueryResult, options: ContractQueryResultParseOptions) => (string | number | BigVal | boolean);
/**
 * Interfaces for working with contracts.
 */
export declare class Contract extends TransactionOptionsBase {
    protected _address: string;
    /**
     * Constructor.
     *
     * @param address Contract address.
     * @param options Transaction options.
     */
    constructor(address: string, options?: TransactionOptions);
    /**
     * Get contract address.
     */
    get address(): string;
    /**
     * Get instance for contract at given address.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * If `options.provider` is set then this checks to ensure that contract code is present at the
     * given address.
     *
     * @param address Contract address.
     * @param options Base options for all subsequent transactions and contract querying.
     */
    static at(address: string, options?: TransactionOptions): Promise<Contract>;
    /**
     * Deploy a contract.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param code Contract bytecode code.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Base options for all subsequent transactions and contract querying.
     */
    static deploy(code: Buffer, metadata: ContractMetadata, initArgs: string[], options: TransactionOptions): Promise<ContractDeploymentTransactionReceipt>;
    /**
     * Compute the would-be address of a deployed contract.
     *
     * The address is computed deterministically, from the address of the deployer and their next transaction nonce.
     *
     * @param deployer Address of contract deployer/owner in bech32 format.
     * @param provider Provider instance.
     */
    static computeDeployedAddress(deployer: string, provider: Provider): Promise<string>;
    /**
     * Compute the would-be address of a deployed contract.
     *
     * The address is computed deterministically, from the address of the deployer and the given transaction nonce.
     *
     * Based on: https://github.com/ElrondNetwork/elrond-sdk/blob/master/erdjs/src/smartcontracts/smartContract.ts#L216
     *
     * @param deployer Address of contract deployer/owner in bech32 format.
     * @param nonce Their nonce at the time of deployment.
     */
    static computeDeployedAddressWithNonce(deployer: string, nonce: number): Promise<string>;
    /**
     * Create a contract deployment transaction.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param code Contract bytecode code.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Transaction options.
     */
    static createDeployment(code: Buffer, metadata: ContractMetadata, initArgs: string[], options: TransactionOptions): TransactionBuilder;
    /**
     * Create a contract upgrade transaction.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param address Contract address.
     * @param code Contract bytecode code.
     * @param metadata Contract metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Transaction options.
     */
    static createUpgrade(address: string, code: Buffer, metadata: ContractMetadata, initArgs: string[], options: TransactionOptions): TransactionBuilder;
    /**
     * Construct a contract function invocation transaction.
     *
     * The `options` parameter should typically at least contain `sender`, `provider` and `signer` so that
     * subsequent interactions can make use of these.
     *
     * @param address Contract address.
     * @param func Function to call.
     * @param args Arguments to pass to function.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    static createInvocation(address: string, func: string, args: string[], options: TransactionOptions): TransactionBuilder;
    /**
     * Query a function in read-only mode, without using a transaction.
     *
     * This will call the given contract function in read-only mode, i.e. without using a transaction.
     *
     * @param func Function to call.
     * @param args Arguments to pass to function.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    query(func: string, args?: string[], options?: TransactionOptions): Promise<ContractQueryResult>;
    /**
     * Invoke a function using a transaction.
     *
     * @param func Function to call.
     * @param args Arguments to pass to function.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    invoke(func: string, args?: string[], options?: TransactionOptions): Promise<TransactionReceipt>;
    /**
     * Upgrade the contract code and metadata.
     *
     * @param code New code.
     * @param metadata New metadata.
     * @param initArgs Arguments for `init()` method.
     * @param options Options which will get merged with the base options set in the constructor.
     */
    upgrade(code: Buffer, metadata: ContractMetadata, initArgs: string[], options?: TransactionOptions): Promise<TransactionReceipt>;
}
