var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BigVal } from 'bigval';
import { Api, TransactionTracker } from '../lib';
import { TransactionStatus, } from '../common';
/**
 * Parse raw transaction data from the chain.
 *
 * @param tx Raw transaction data.
 */
export const parseRawTransaction = (tx) => {
    // status parsing: https://docs.elrond.com/querying-the-blockchain#transaction-status
    let status;
    switch (tx.status) {
        case 'success':
        case 'executed':
            status = TransactionStatus.SUCCESS;
            break;
        case 'invalid':
        case 'fail':
        case 'not-executed':
            status = TransactionStatus.FAILURE;
            break;
        default:
            status = TransactionStatus.PENDING;
    }
    const smartContractResults = tx.smartContractResults || [];
    // check smart contract results
    let smartContractErrors = [];
    smartContractResults.forEach((res) => {
        if (res.returnMessage) {
            smartContractErrors.push(res.returnMessage);
        }
    });
    if (smartContractErrors.length) {
        status = TransactionStatus.FAILURE;
    }
    return Object.assign(Object.assign({ raw: tx }, tx), { smartContractResults,
        smartContractErrors,
        status });
};
/**
 * A `Provider` which speaks to an Elrond Proxy endpoint.
 */
export class ProxyProvider extends Api {
    /**
     * Constructor.
     *
     * @param api Proxy endpoint base URL.
     * @param config Configuration.
     */
    constructor(api, config) {
        super(api, config);
    }
    /**
     * Sanitize balance value returned from the Elrond proxy.
     * @param balance
     */
    _sanitizeBalance(balance) {
        if (balance === '<nil>') {
            return new BigVal(0);
        }
        else {
            return new BigVal(balance);
        }
    }
    /**
     * Parse a reponse.
     *
     * @param data The returned data to parse.
     * @param errorMsg Prefix for any error messages thrown.
     * @throws {Error} If response indicates a failure or parsing failed.
     */
    _parseResponse(data, errorMsg) {
        if (!data) {
            throw new Error(`No data returned`);
        }
        if (data.error || (data.code !== 'successful')) {
            throw new Error(`${errorMsg}: ${data.error || data.code || 'internal error'}`);
        }
        if (undefined === data.data) {
            throw new Error(`${errorMsg}: no data returned`);
        }
        return data.data;
    }
    getNetworkConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield this._call(`/network/config`);
            const { config } = this._parseResponse(ret, 'Error fetching network config') || {};
            return {
                version: config.erd_latest_tag_software_version,
                chainId: config.erd_chain_id,
                gasPerDataByte: config.erd_gas_per_data_byte,
                minGasPrice: config.erd_min_gas_price,
                minGasLimit: config.erd_min_gas_limit,
                minTransactionVersion: config.erd_min_transaction_version,
            };
        });
    }
    getAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield this._call(`/address/${address}`);
            const { account } = this._parseResponse(ret, 'Error fetching address info');
            return Object.assign(Object.assign({}, account), { balance: this._sanitizeBalance(account.balance) });
        });
    }
    getESDTData(address, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield this._call(`/address/${address}/esdt/${token}`);
            const { tokenData } = this._parseResponse(ret, 'Error fetching ESDT info');
            return {
                id: token,
                balance: this._sanitizeBalance(tokenData.balance),
            };
        });
    }
    queryContract(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const obj = {
                scAddress: params.contractAddress,
                funcName: params.functionName,
                args: params.args,
                caller: params.caller,
            };
            if (params.value) {
                obj.value = params.value.toString();
            }
            const ret = yield this._call(`/vm-values/query`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                data: JSON.stringify(obj),
            });
            const { data } = this._parseResponse(ret, `Error querying contract`);
            return data;
        });
    }
    sendSignedTransaction(signedTx) {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield this._call(`/transaction/send`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                data: JSON.stringify(signedTx)
            });
            const { txHash: hash } = this._parseResponse(ret, 'Error sending transaction');
            return hash;
        });
    }
    waitForTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return new TransactionTracker(this, txHash).waitForCompletion();
        });
    }
    getTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield this._call(`/transaction/${txHash}?withResults=true`, {
                method: 'GET',
            });
            const { transaction: txData } = this._parseResponse(ret, 'Error fetching transaction');
            if (!txData) {
                throw new Error(`Transaction not found`);
            }
            return parseRawTransaction(txData);
        });
    }
}
