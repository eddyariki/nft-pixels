import { Provider, Transaction, TransactionOptions, TransactionReceipt } from "../common";
/**
 * Transaction tracker.
 *
 * This is used by the `ProxyProvider.waitForTransaction()` method.
 */
export declare class TransactionTracker {
    _txHash: string;
    _provider: Provider;
    /**
     * Constructor.
     * @param provider The provider to check with.
     * @param txHash The transaction hash.
     */
    constructor(provider: Provider, txHash: string);
    /**
     * Wait until this transaction has finished executing.
     *
     * @throws {TransactionFailedError} If transaction fails or transaction tracking fails for whatever reason.
     */
    waitForCompletion(): Promise<TransactionReceipt>;
}
/**
 * Base class for all implementations which make use of `TransactionOptions` whereby options are first
 * provided in the constructor and can then be overridden on a per-call basis.
 * @internal
 */
export declare abstract class TransactionOptionsBase {
    protected _options?: TransactionOptions;
    /**
     * Constructor.
     * @param options Base transaction options.
     */
    constructor(options?: TransactionOptions);
    /**
     * Merge given options with options set in the constructor.
     *
     * The options in the constructor will be extended with the given options and a new object will
     * be returned, leaving the originals unmodified.
     *
     * @param options Options to merge.
     * @param fieldsToCheck Fields to check the presence of. If any of these fields are missing an error will be thrown.
     * @throws {Errors} If any field listed in `fieldsToCheck` is absent in the final merged options object.
     */
    protected _mergeTransactionOptions(options?: TransactionOptions, ...fieldsToCheck: string[]): TransactionOptions;
}
/**
 * Generic transaction builder base class.
 */
export declare abstract class TransactionBuilder {
    protected _options?: TransactionOptions;
    /**
     * Constructor.
     *
     * @param options Transaction options.
     */
    constructor(options?: TransactionOptions);
    /**
     * Get the `data` string representation of this transaction.
     */
    abstract getTransactionDataString(): string;
    /**
     * Get `receiver` address.
     */
    abstract getReceiverAddress(): string;
    /**
     * Get signable transaction representation of thisÂ transaction.
     */
    toTransaction(): Promise<Transaction>;
}
/**
 * Get a copy of given transaction with default gas price and limit set.
 *
 * @param tx The transaction.
 * @param provider The provider.
 */
export declare const setDefaultGasPriceAndLimit: (tx: Transaction, provider: Provider) => Promise<Transaction>;
/**
 * Verify that given transaction options contain certain fields specified.
 *
 * @param options Transaction options.
 * @param fieldsToCheck The fields to check for.
 * @throws {Error} if transaction options are empty or any required fields are missing.
 */
export declare const verifyTransactionOptions: (options?: TransactionOptions | undefined, ...fieldsToCheck: string[]) => void;
/**
 * Generate transaction data arguments from given key-value map.
 * @param keyValueMap The key-value map.
 */
export declare const convertMapToDataArguments: (keyValueMap: object) => string[];
/**
 * Join arguments for transaction data field.
 * @internal
 */
export declare const joinDataArguments: (...args: string[]) => string;
