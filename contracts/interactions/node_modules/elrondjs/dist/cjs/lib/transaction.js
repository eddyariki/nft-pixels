"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinDataArguments = exports.convertMapToDataArguments = exports.verifyTransactionOptions = exports.setDefaultGasPriceAndLimit = exports.TransactionBuilder = exports.TransactionOptionsBase = exports.TransactionTracker = void 0;
const bigval_1 = require("bigval");
const common_1 = require("../common");
const errors_1 = require("../errors");
const utils_1 = require("./utils");
/**
 * Transaction tracker.
 *
 * This is used by the `ProxyProvider.waitForTransaction()` method.
 */
class TransactionTracker {
    /**
     * Constructor.
     * @param provider The provider to check with.
     * @param txHash The transaction hash.
     */
    constructor(provider, txHash) {
        this._provider = provider;
        this._txHash = txHash;
    }
    /**
     * Wait until this transaction has finished executing.
     *
     * @throws {TransactionFailedError} If transaction fails or transaction tracking fails for whatever reason.
     */
    waitForCompletion() {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = {
                hash: this._txHash
            };
            return new Promise((resolve, reject) => {
                const _wait = () => {
                    setTimeout(() => {
                        this._provider.getTransaction(this._txHash)
                            .then(txOnChain => {
                            receipt.transactionOnChain = txOnChain;
                            switch (txOnChain.status) {
                                case common_1.TransactionStatus.FAILURE:
                                    let errMsg = `Transaction failed: ${receipt.hash}`;
                                    if (txOnChain.smartContractErrors.length) {
                                        errMsg = `Smart contract error:\n\n${txOnChain.smartContractErrors.join("\n")}`;
                                    }
                                    reject(new errors_1.TransactionFailedError(errMsg, receipt));
                                    break;
                                case common_1.TransactionStatus.SUCCESS:
                                    resolve(receipt);
                                    break;
                                default:
                                    _wait();
                            }
                        })
                            .catch(err => {
                            reject(new errors_1.TransactionFailedError(`Error checking transaction ${this._txHash}: ${err.message}`));
                        });
                    }, 5000 /* check every 5 seconds */);
                };
                // start the loop
                _wait();
            });
        });
    }
}
exports.TransactionTracker = TransactionTracker;
/**
 * Base class for all implementations which make use of `TransactionOptions` whereby options are first
 * provided in the constructor and can then be overridden on a per-call basis.
 * @internal
 */
class TransactionOptionsBase {
    /**
     * Constructor.
     * @param options Base transaction options.
     */
    constructor(options) {
        this._options = options;
    }
    /**
     * Merge given options with options set in the constructor.
     *
     * The options in the constructor will be extended with the given options and a new object will
     * be returned, leaving the originals unmodified.
     *
     * @param options Options to merge.
     * @param fieldsToCheck Fields to check the presence of. If any of these fields are missing an error will be thrown.
     * @throws {Errors} If any field listed in `fieldsToCheck` is absent in the final merged options object.
     */
    _mergeTransactionOptions(options, ...fieldsToCheck) {
        const mergedOptions = Object.assign({}, this._options, options);
        exports.verifyTransactionOptions(mergedOptions, ...fieldsToCheck);
        return mergedOptions;
    }
}
exports.TransactionOptionsBase = TransactionOptionsBase;
/**
 * Generic transaction builder base class.
 */
class TransactionBuilder {
    /**
     * Constructor.
     *
     * @param options Transaction options.
     */
    constructor(options) {
        this._options = options;
    }
    /**
     * Get signable transaction representation of thisÂ transaction.
     */
    toTransaction() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._options) {
                throw new Error('Execution options must be set');
            }
            if (!((_a = this._options) === null || _a === void 0 ? void 0 : _a.sender)) {
                throw new Error('Sender must be set');
            }
            if (!((_b = this._options) === null || _b === void 0 ? void 0 : _b.provider)) {
                throw new Error('Provider must be set');
            }
            const tx = yield exports.setDefaultGasPriceAndLimit({
                sender: this._options.sender,
                receiver: this.getReceiverAddress(),
                value: this._options.value || new bigval_1.BigVal(0),
                data: this.getTransactionDataString(),
                meta: this._options.meta,
            }, this._options.provider);
            tx.gasPrice = this._options.gasPrice || tx.gasPrice;
            tx.gasLimit = this._options.gasLimit || tx.gasLimit;
            return tx;
        });
    }
}
exports.TransactionBuilder = TransactionBuilder;
/**
 * Get a copy of given transaction with default gas price and limit set.
 *
 * @param tx The transaction.
 * @param provider The provider.
 */
exports.setDefaultGasPriceAndLimit = (tx, provider) => __awaiter(void 0, void 0, void 0, function* () {
    const networkConfig = yield provider.getNetworkConfig();
    const gasPrice = networkConfig.minGasPrice;
    const gasLimit = networkConfig.minGasLimit + networkConfig.gasPerDataByte * (tx.data || '').length;
    return Object.assign(Object.assign({}, tx), { gasPrice,
        gasLimit });
});
/**
 * Verify that given transaction options contain certain fields specified.
 *
 * @param options Transaction options.
 * @param fieldsToCheck The fields to check for.
 * @throws {Error} if transaction options are empty or any required fields are missing.
 */
exports.verifyTransactionOptions = (options, ...fieldsToCheck) => {
    if (!options) {
        throw new Error('Transaction options are empty');
    }
    if (fieldsToCheck.length) {
        fieldsToCheck.forEach(field => {
            if (!options[field]) {
                throw new Error(`${field} must be set`);
            }
        });
    }
};
/**
 * Generate transaction data arguments from given key-value map.
 * @param keyValueMap The key-value map.
 */
exports.convertMapToDataArguments = (keyValueMap) => {
    return Object.keys(keyValueMap).reduce((m, v) => {
        m.push(utils_1.stringToHex(v));
        m.push(utils_1.stringToHex(keyValueMap[v] ? 'true' : 'false'));
        return m;
    }, []);
};
/**
 * Join arguments for transaction data field.
 * @internal
 */
exports.joinDataArguments = (...args) => {
    return args.join(utils_1.ARGS_DELIMITER);
};
