var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import axios from 'axios';
/**
 * Base class for API interfaces.
 *
 * This provides convenience methods for making request and performing basic response parsing.
 */
export class Api {
    /**
     * @param baseUrl The root endpoint for all API requests.
     * @param config Configuration
     */
    constructor(baseUrl, config) {
        var _a, _b, _c;
        this._baseUrl = baseUrl;
        this._config = config;
        this._defaultOptions = {
            timeout: ((_a = config === null || config === void 0 ? void 0 : config.callOptions) === null || _a === void 0 ? void 0 : _a.timeout) || 3000,
            responseType: ((_b = config === null || config === void 0 ? void 0 : config.callOptions) === null || _b === void 0 ? void 0 : _b.responseType) || 'json',
            headers: ((_c = config === null || config === void 0 ? void 0 : config.callOptions) === null || _c === void 0 ? void 0 : _c.headers) || {},
        };
        this._axios = axios.create({
            baseURL: baseUrl,
        });
    }
    /**
     * Make a request.
     *
     * Note that any request options supplied via the `options` parameter will override those
     * set in the constructor.
     *
     * @param urlPath The API path relative to the root endpoint configured in the constructor.
     * @param options Request options. Will override those set in the constructor.
     * @return {any}
     * @throws {Error} If the response was an error.
     */
    _call(urlPath, options) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            let ret;
            const finalOpts = {
                timeout: (options === null || options === void 0 ? void 0 : options.timeout) || this._defaultOptions.timeout,
                responseType: (options === null || options === void 0 ? void 0 : options.responseType) || this._defaultOptions.responseType,
                headers: Object.assign({}, this._defaultOptions.headers, options === null || options === void 0 ? void 0 : options.headers),
                data: (options === null || options === void 0 ? void 0 : options.data) || undefined,
                method: (options === null || options === void 0 ? void 0 : options.method) || 'GET'
            };
            try {
                if ((_a = this._config) === null || _a === void 0 ? void 0 : _a.onRequest) {
                    (_b = this._config) === null || _b === void 0 ? void 0 : _b.onRequest(urlPath, finalOpts);
                }
                ret = yield this._axios.request(Object.assign({ url: urlPath }, finalOpts));
                if ((_c = this._config) === null || _c === void 0 ? void 0 : _c.onResponse) {
                    (_d = this._config) === null || _d === void 0 ? void 0 : _d.onResponse(urlPath, finalOpts, ret);
                }
                return this._responseTransformer(ret);
            }
            catch (err) {
                if ((_e = this._config) === null || _e === void 0 ? void 0 : _e.onResponse) {
                    (_f = this._config) === null || _f === void 0 ? void 0 : _f.onResponse(urlPath, finalOpts, undefined, err);
                }
                return this._responseTransformer(undefined, err);
            }
        });
    }
    /**
     * Default response transformer.
     *
     * This gets passed the response of every request. Subclasses may override
     * this to customize resposne handling.
     *
     * @param ret The response.
     * @param error Request error that thrown.
     * @return {any} The transformed response.
     * @throws {Error} If the response was an error.
     */
    _responseTransformer(ret, error) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (error) {
                if ((_b = (_a = error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) {
                    throw new Error(error.response.data.error);
                }
            }
            else if (ret) {
                const { data, error } = ret;
                if (error) {
                    throw new Error(error.message);
                }
                return data || ret;
            }
            else {
                throw new Error('Invalid response transformer call');
            }
        });
    }
}
