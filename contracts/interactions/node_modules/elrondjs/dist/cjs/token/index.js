"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = exports.METACHAIN_TOKEN_CONTRACT = exports.parseTokenInfo = void 0;
const bigval_1 = require("bigval");
const common_1 = require("../common");
const lib_1 = require("../lib");
const contract_1 = require("../contract");
const ESDT_TRANSFER_METHOD = 'ESDTTransfer';
/**
 * Parse token info result.
 *
 * Wrapper around `parseQueryResult()` which performs additional processing.
 *
 * @param result The query result.
 * @param options Parsing options.
 *
 * @internal
 */
exports.parseTokenInfo = (result, options, regex) => {
    const inputVal = contract_1.parseQueryResult(result, Object.assign(Object.assign({}, options), { type: common_1.ContractQueryResultDataType.STRING }));
    const parsed = regex.exec(inputVal);
    const parsedVal = parsed ? parsed[1] : '';
    switch (options.type) {
        case common_1.ContractQueryResultDataType.BOOLEAN: {
            if (!parsedVal) {
                return false;
            }
            else {
                return parsedVal.includes('true');
            }
        }
        case common_1.ContractQueryResultDataType.BIG_INT:
        case common_1.ContractQueryResultDataType.INT: {
            let ret;
            if (!parsedVal) {
                ret = new bigval_1.BigVal(0);
            }
            else {
                ret = new bigval_1.BigVal(parsedVal);
            }
            return (options.type === common_1.ContractQueryResultDataType.INT ? ret.toNumber() : ret);
        }
        case common_1.ContractQueryResultDataType.ADDRESS: {
            return lib_1.hexStringToAddress(lib_1.queryResultValueToHex(inputVal));
        }
        case common_1.ContractQueryResultDataType.HEX: {
            if (!parsedVal) {
                return '0x0';
            }
            else {
                return lib_1.queryResultValueToHex(inputVal);
            }
        }
        case common_1.ContractQueryResultDataType.STRING:
        default: {
            return parsedVal;
        }
    }
};
/**
 * Address of metachain contract which handles ESDT token issuance and all other operations.
 */
exports.METACHAIN_TOKEN_CONTRACT = 'erd1qqqqqqqqqqqqqqqpqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqzllls8a5w6u';
/**
 * Gas limit to use for most token management operations.
 * @internal
 */
const TOKEN_MGMT_STANDARD_GAS_COST = 51000000;
/**
 * Token creation cost.
 * @internal
 */
const TOKEN_CREATION_COST = new bigval_1.BigVal(5, 'coins'); // 5 eGLD
/**
 * Builder for token transfer transactions.
 */
class TokenTransferBuilder extends lib_1.TransactionBuilder {
    /**
     * Constructor.
     *
     * @param receiver Address to transfer to.
     * @param tokenId Id of token.
     * @param amount No. of tokens to transfer.
     * @param options Transaction options.
     */
    constructor(receiver, tokenId, amount, options) {
        super(options);
        this._receiver = receiver;
        this._tokenId = tokenId;
        this._amount = amount;
    }
    getTransactionDataString() {
        return lib_1.joinDataArguments(ESDT_TRANSFER_METHOD, lib_1.stringToHex(this._tokenId), lib_1.numberToHex(this._amount));
    }
    getReceiverAddress() {
        return this._receiver;
    }
}
/**
 * Interface for working with ESDT tokens.
 */
class Token extends lib_1.TransactionOptionsBase {
    /**
     * Constructor.
     *
     * @param id Token identifier.
     * @param contractInstance `Contract` instance for performing operations.
     * @param options Base transaction options.
     */
    constructor(id, contractInstance, options) {
        super(options);
        this._id = id;
        this._contractInstance = contractInstance;
    }
    /**
     * Get token id.
     */
    get id() {
        return this._id;
    }
    /**
     * Get all token identifiers in system.
     * @param options Transaction options for interacting with the blockchain. These will be the default options used for all subsequent operations.
     */
    static getAllTokenIds(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const c = new contract_1.Contract(exports.METACHAIN_TOKEN_CONTRACT, options);
            const ret = yield c.query('getAllESDTTokens');
            const tokenListStr = contract_1.parseQueryResult(ret, { type: common_1.ContractQueryResultDataType.STRING });
            return tokenListStr.split(lib_1.ARGS_DELIMITER);
        });
    }
    /**
     * Create a new token.
     *
     * Token name must be between 10 and 20 characters (inclusive) and must only contain alphanumeric characters: `[A-Za-z0-9]`.
     * Ticker name must be between 3 and 10 characters (inclusive) and must only contain capital alphanumeric characters: `[A-Z0-9]`.
     *
     * @param name Human-readable name of token.
     * @param ticker Ticker name of token.
     * @param initialSupply Initial total supply of the token, taking into account the no. of decimal places. Denominated in base-10.
     * @param numDecimals No. of decimals token balances have. The recommended value is 18.
     * @param initialConfig Initial token configuration.
     * @param options Transaction options for interacting with the blockchain. These will be the default options used for all subsequent operations.
     */
    static new(name, ticker, initialSupply, numDecimals = 18, initialConfig, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const c = new contract_1.Contract(exports.METACHAIN_TOKEN_CONTRACT, options);
            const tx = yield c.invoke('issue', [
                lib_1.stringToHex(name),
                lib_1.stringToHex(ticker),
                lib_1.numberToHex(initialSupply),
                lib_1.numberToHex(numDecimals),
                ...lib_1.convertMapToDataArguments(initialConfig)
            ], {
                gasLimit: TOKEN_MGMT_STANDARD_GAS_COST,
                value: TOKEN_CREATION_COST /* 5 eGLD */
            });
            const ret = yield options.provider.waitForTransaction(tx.hash);
            // find out token id
            let tokenId;
            try {
                for (let result of ret.transactionOnChain.smartContractResults) {
                    const { data } = result;
                    if (data.startsWith(ESDT_TRANSFER_METHOD)) {
                        const toks = data.split(lib_1.ARGS_DELIMITER);
                        tokenId = lib_1.hexToString(toks[1]);
                        if (!tokenId) {
                            throw new Error('Id not found in transfer result');
                        }
                        break;
                    }
                }
                if (!tokenId) {
                    throw new Error('Transfer result not found');
                }
            }
            catch (err) {
                throw new Error(`Unable to extract token id: ${err.message}`);
            }
            return new Token(tokenId, c, options);
        });
    }
    /**
     * Load a token.
     *
     * This will throw an error if the given token doesn't exist.
     *
     * @param id Token identifier.
     * @param options Transaction options for interacting with the blockchain. These will be the default options used for all subsequent operations.
     */
    static load(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const c = new contract_1.Contract(exports.METACHAIN_TOKEN_CONTRACT, options);
            const t = new Token(id, c, options);
            yield t.getInfo();
            return t;
        });
    }
    /**
     * Get token information.
     *
     * @param options Transaction options to override the default ones with.
     */
    getInfo(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield this._contractInstance.query('getTokenProperties', [
                lib_1.stringToHex(this._id)
            ], options);
            return {
                id: this._id,
                name: contract_1.parseQueryResult(ret, { type: common_1.ContractQueryResultDataType.STRING, index: 0 }),
                ticker: this._id.substr(0, this._id.indexOf('-')),
                owner: contract_1.parseQueryResult(ret, { type: common_1.ContractQueryResultDataType.ADDRESS, index: 1 }),
                supply: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BIG_INT, index: 2 }, /(.+)/),
                decimals: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.INT, index: 4 }, /NumDecimals\-(.+)/),
                paused: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 5 }, /IsPaused\-(.+)/),
                config: {
                    canUpgrade: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 6 }, /CanUpgrade\-(.+)/),
                    canMint: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 7 }, /CanMint\-(.+)/),
                    canBurn: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 8 }, /CanBurn\-(.+)/),
                    canChangeOwner: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 9 }, /CanChangeOwner\-(.+)/),
                    canPause: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 10 }, /CanPause\-(.+)/),
                    canFreeze: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 11 }, /CanFreeze\-(.+)/),
                    canWipe: exports.parseTokenInfo(ret, { type: common_1.ContractQueryResultDataType.BOOLEAN, index: 12 }, /CanWipe\-(.+)/),
                }
            };
        });
    }
    /**
     * Get balance of given address.
     *
     * @param address Address in bech-32 format.
     * @param options Transaction options to override the default ones with.
     */
    balanceOf(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = yield this._mergeTransactionOptions(options, 'provider');
            const { balance } = yield opts.provider.getESDTData(address, this.id);
            return balance;
        });
    }
    /**
     * Transfer tokens to another address.
     *
     * @param to Address to transfer to.
     * @param amount No. of tokens to transfer.
     * @param options Transaction options to override the default ones with.
     */
    transfer(to, amount, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = this._mergeTransactionOptions(Object.assign({ gasLimit: 500000 }, options), 'sender', 'provider', 'signer');
            const builder = new TokenTransferBuilder(to, this._id, amount, opts);
            const tx = yield builder.toTransaction();
            const signedTx = yield opts.signer.signTransaction(tx, opts.provider);
            const hash = yield opts.provider.sendSignedTransaction(signedTx);
            return opts.provider.waitForTransaction(hash);
        });
    }
    /**
     * Mint more tokens.
     *
     * @param amount Amount to mint.
     * @param address Address to mint to. If ommitted tokens will be minted to the current config owner.
     * @param options Transaction options to override the default ones with.
     */
    mint(amount, address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('mint', [
                lib_1.stringToHex(this._id),
                lib_1.numberToHex(amount),
                ...(address ? [lib_1.addressToHexString(address)] : [])
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
    /**
     * Burn one's own tokens.
     * @param amount Amount to burn.
     * @param options Transaction options to override the default ones with.
     */
    burn(amount, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('ESDTBurn', [
                lib_1.stringToHex(this._id),
                lib_1.numberToHex(amount)
            ], Object.assign({ gasLimit: 2500000 }, options));
        });
    }
    /**
     * Pause token transfers, but continue to allow burning and minting.
     * @param options Transaction options to override the default ones with.
     */
    pause(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('pause', [
                lib_1.stringToHex(this._id),
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
    /**
     * Unpause token transfers.
     * @param options Transaction options to override the default ones with.
     */
    unPause(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('unPause', [
                lib_1.stringToHex(this._id),
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
    /**
     * Freeze transfers to/from a specific account.
     * @param address Account address in bech32 format.
     * @param options Transaction options to override the default ones with.
     */
    freeze(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('freeze', [
                lib_1.stringToHex(this._id),
                lib_1.addressToHexString(address),
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
    /**
     * Unfreeze transfers to/from a specific account.
     * @param address Account address in bech32 format.
     * @param options Transaction options to override the default ones with.
     */
    unFreeze(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('unFreeze', [
                lib_1.stringToHex(this._id),
                lib_1.addressToHexString(address),
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
    /**
     * Wipe all tokens from a currently frozen account.
     * @param address Account address in bech32 format.
     * @param options Transaction options to override the default ones with.
     */
    wipe(address, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('wipe', [
                lib_1.stringToHex(this._id),
                lib_1.addressToHexString(address),
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
    /**
     * Transfer ownership of token to another account.
     * @param newOwner New owner's address in bech32 format.
     * @param options Transaction options to override the default ones with.
     */
    changeOwner(newOwner, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._contractInstance.invoke('transferOwnership', [
                lib_1.stringToHex(this._id),
                lib_1.addressToHexString(newOwner),
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
    /**
     * Update the token configuration.
     * @param newConfig New token configuration.
     * @param options Transaction options to override the default ones with.
     */
    updateConfig(newConfig, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = lib_1.convertMapToDataArguments(newConfig);
            return yield this._contractInstance.invoke('controlChanges', [
                lib_1.stringToHex(this._id),
                ...data,
            ], Object.assign({ gasLimit: TOKEN_MGMT_STANDARD_GAS_COST }, options));
        });
    }
}
exports.Token = Token;
