"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerWallet = void 0;
const hw_app_elrond_1 = __importDefault(require("@elrondnetwork/hw-app-elrond"));
const base_1 = require("./base");
/**
 * @internal
 */
const SERIALIZATION_PREFIX = '[LedgerWallet]';
/**
 * @internal
 */
const withLedgerAppInstance = (transport, cb) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const ledgerTransportInstance = yield new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
            const timer = setTimeout(() => {
                reject(new Error('Cannot write to Ledger transport'));
            }, 2000);
            let t;
            try {
                t = yield transport.create();
            }
            catch (err) {
                reject(new Error(`Ledger transport failed: ${err.message}`));
            }
            finally {
                if (t) {
                    clearTimeout(timer);
                    resolve(t);
                }
            }
        }));
        // get the result and then close the transport
        let ret;
        let error;
        try {
            ret = yield cb(new hw_app_elrond_1.default(ledgerTransportInstance), ledgerTransportInstance);
        }
        catch (err) {
            error = err;
        }
        yield ledgerTransportInstance.close();
        if (ret) {
            return ret;
        }
        if (error) {
            throw error;
        }
    }
    catch (err) {
        console.error(err);
        const msg = err.message.toLowerCase();
        const notOpenError = msg.includes('cannot write')
            || msg.includes('cannot open')
            || msg.includes('is busy')
            || msg.includes('0x6e');
        const openElsewhereError = msg.includes('unable to reset')
            || msg.includes('unable to claim');
        if (notOpenError) {
            throw new Error('Please ensure that your Ledger is connected and that the Elrond app is open');
        }
        else if (openElsewhereError) {
            throw new Error('Your ledger is already in use with another browser tab or application');
        }
        else if (msg.includes('0x6985')) {
            throw new Error('The transaction was rejected on the Ledger');
        }
        else {
            throw err;
        }
    }
});
/**
 * Ledger hardware wallet.
 */
class LedgerWallet extends base_1.WalletBase {
    /**
     * Constructor.
     */
    constructor(transport, address) {
        super();
        this._transport = transport;
        this._address = address;
        this._activeTransportInstances = {};
    }
    /**
     * Get whether there are pending actions on the Ledger.
     *
     * If there are pending actions then Ledger transport instances cannot be closed until the user either
     * accepts or rejects those actions on the Ledger.
     */
    hasPendingActions() {
        return Object.values(this._activeTransportInstances).length > 0;
    }
    /**
     * Connect to the Ledger hardware wallet.
     *
     * @param ledgerTransports The various Ledger transports to try.
     * @throws {Error} If it fails to connect.
     */
    static connect(ledgerTransports) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let t of ledgerTransports) {
                const isSupported = yield t.isSupported();
                if (isSupported) {
                    return yield withLedgerAppInstance(t, (elrondLedgerApp) => __awaiter(this, void 0, void 0, function* () {
                        const { address } = yield elrondLedgerApp.getAddress();
                        return new LedgerWallet(t, address);
                    }));
                }
            }
            throw new Error('Ledger transports not supported');
        });
    }
    _withLedger(cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield withLedgerAppInstance(this._transport, (erdLedgerInstance, ledgerTransportInstance) => __awaiter(this, void 0, void 0, function* () {
                // keep track of this open transport instance, and clean it up later below once we're done with it
                const instanceId = Math.random().toString();
                this._activeTransportInstances[instanceId] = ledgerTransportInstance;
                try {
                    let ret = yield cb(erdLedgerInstance);
                    delete this._activeTransportInstances[instanceId];
                    return ret;
                }
                catch (err) {
                    delete this._activeTransportInstances[instanceId];
                    throw err;
                }
            }));
        });
    }
    _sign(rawTx) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._withLedger((erdLedgerInstance) => __awaiter(this, void 0, void 0, function* () {
                const { contractData } = yield erdLedgerInstance.getAppConfiguration();
                if ('1' != contractData) {
                    throw new Error('Please enable "Contract Data" in the Elrond ledger app settings.');
                }
                const signedTx = yield erdLedgerInstance.signTransaction(rawTx);
                return signedTx;
            }));
        });
    }
    _getAddress() {
        return this._address;
    }
    serialize() {
        return `${SERIALIZATION_PREFIX}${JSON.stringify(this._address)}`;
    }
}
exports.LedgerWallet = LedgerWallet;
