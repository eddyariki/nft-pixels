"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryResultValueToString = exports.queryResultValueToHex = exports.ADDRESS_ZERO_BECH32 = exports.ADDRESS_ZERO_HEX = exports.getNameShard = exports.getAddressShard = exports.NUM_SHARDS = exports.hexStringToAddress = exports.addressToHexString = exports.contractMetadataToString = exports.keccak = exports.numberToHex = exports.hexToString = exports.stringToHex = exports.ARWEN_VIRTUAL_MACHINE = exports.ARGS_DELIMITER = void 0;
const bech32_1 = __importDefault(require("bech32"));
const buffer_1 = require("buffer");
const keccak_1 = __importDefault(require("keccak"));
const bigval_1 = require("bigval");
/**
 * Common argument delimiter in elrond.
 */
exports.ARGS_DELIMITER = '@';
/**
 * Arwen VM indicator value.
 */
exports.ARWEN_VIRTUAL_MACHINE = '0500';
/**
 * Convert ASCII string to its HEX representation.
 * @param arg ASCII string.
 */
exports.stringToHex = (arg) => {
    return arg.split('').map(c => ('0' + c.charCodeAt(0).toString(16)).slice(-2)).join('');
};
/**
 * Convert Hex string to its ASCII representation.
 * @param arg hex string.
 */
exports.hexToString = (arg) => {
    return buffer_1.Buffer.from(arg, 'hex').toString('utf8');
};
/**
 * Convert number to its HEX representation.
 *
 * This will prefix the returned string with `0`'s in order to ensure an even length.
 *
 * If `number` is a `BigVal` then it will be converted to its smallest scale prior to generating a hex representation.
 *
 * @param arg number.
 */
exports.numberToHex = (arg) => {
    let str = new bigval_1.BigVal(arg).toMinScale().toString(16).substr(2);
    if (str.length % 2 !== 0) {
        str = `0${str}`;
    }
    return str;
};
/**
 * Get KECCAK hash of given input
 * @param bytes The input.
 */
exports.keccak = (bytes) => {
    return keccak_1.default("keccak256").update(bytes).digest();
};
/**
 * Get string representation of given contract metadata.
 *
 * (Forked from https://github.com/ElrondNetwork/elrond-sdk/blob/master/erdjs/src/smartcontracts/codeMetadata.ts)
 *
 * @param contractMetadata Contract metadata.
 */
exports.contractMetadataToString = (contractMetadata) => {
    let byteZero = 0;
    let byteOne = 0;
    if (contractMetadata.upgradeable) {
        byteZero |= 1;
    }
    if (contractMetadata.readable) {
        byteZero |= 4;
    }
    if (contractMetadata.payable) {
        byteOne |= 2;
    }
    return `0${byteZero}0${byteOne}`;
};
/**
 * Get hex representation of given bech32 address.
 *
 * @param address The address in bech32 format.
 */
exports.addressToHexString = (address) => {
    const { words } = bech32_1.default.decode(address, 256);
    return buffer_1.Buffer.from(bech32_1.default.fromWords(words)).toString('hex');
};
/**
 * Get bech32 address from its hex representation.
 *
 * @param hex The address in hex format.
 */
exports.hexStringToAddress = (hex) => {
    const words = bech32_1.default.toWords(buffer_1.Buffer.from(hex, 'hex'));
    return bech32_1.default.encode('erd', words);
};
/**
 * Max no. of shards.
 */
exports.NUM_SHARDS = 3;
/**
 * Get shard number for given address.
 *
 * @param address The address in bech32 format.
 * @param numShards The no. of shards in the network.
 * @return -1 if metachain, >=0 otherwise
 */
exports.getAddressShard = (address, numShards = exports.NUM_SHARDS) => {
    const buf = buffer_1.Buffer.from(exports.addressToHexString(address), "hex");
    return getShard(buf, numShards);
};
/**
 * Get shard number for given DNS name.
 *
 * @param name The DNS name.
 * @param numShards The no. of shards in the network.
 * @return -1 if metachain, >=0 otherwise
 */
exports.getNameShard = (name, numShards = exports.NUM_SHARDS) => {
    const buf = exports.keccak(buffer_1.Buffer.from(name, 'utf8'));
    return buf[31];
};
/**
 * @internal
 */
const getShard = (buf, numShards = exports.NUM_SHARDS) => {
    /* derived from https://github.com/ElrondNetwork/elrond-sdk/blob/721b587d849c0af659e3697ae3c06e084d9916d6/examples/shards.js */
    if (isMetachainAddress(buf)) {
        return -1;
    }
    const lastByteOfPubKey = buf[31];
    let shard = lastByteOfPubKey & 3;
    if (shard > numShards - 1) {
        shard = lastByteOfPubKey & 1;
    }
    return shard;
};
/**
 * Forked from https://github.com/ElrondNetwork/elrond-sdk/blob/721b587d849c0af659e3697ae3c06e084d9916d6/examples/shards.js
 * @internal
 */
const isMetachainAddress = (pubKey) => {
    let metachainPrefix = buffer_1.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    let pubKeyPrefix = pubKey.slice(0, metachainPrefix.length);
    if (pubKeyPrefix.equals(metachainPrefix)) {
        return true;
    }
    let zeroAddress = buffer_1.Buffer.alloc(32).fill(0);
    if (pubKey.equals(zeroAddress)) {
        return true;
    }
    return false;
};
/**
 * The NULL address in HEX format.
 */
exports.ADDRESS_ZERO_HEX = '0'.repeat(64);
/**
 * The NULL address in bech32 format.
 */
exports.ADDRESS_ZERO_BECH32 = 'erd1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq6gq4hu'; // = hexStringToAddress(ADDRESS_ZERO_HEX)
/**
 * Convert query result value to hex.
 * @internal
 */
exports.queryResultValueToHex = (val) => buffer_1.Buffer.from(val, 'base64').toString('hex');
/**
 * Convert query result value to string.
 * @internal
 */
exports.queryResultValueToString = (val) => buffer_1.Buffer.from(val, 'base64').toString('utf8');
