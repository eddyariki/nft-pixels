"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicWallet = exports.generateMnemonic = void 0;
const buffer_1 = require("buffer");
const bip39 = __importStar(require("bip39"));
const bech32_1 = __importDefault(require("bech32"));
const crypto_1 = __importDefault(require("crypto"));
const base_1 = require("./base");
const ed25519Keypair_1 = require("./crypto/browser/ed25519Keypair");
const keyDerivation_1 = require("./crypto/browser/keyDerivation");
/**
 * @internal
 */
const PEM_REGEX = /-----BEGIN[^-]+-----([^-]+)-----END[^-]+/igm;
/**
 * @internal
 */
const MNEMONIC_LEN = 256;
/**
 * @internal
 */
const SERIALIZATION_PREFIX = '[BasicWallet]';
/**
 * Generate a random mnemonic.
 */
exports.generateMnemonic = () => {
    return bip39.generateMnemonic(MNEMONIC_LEN);
};
/**
 * @internal
 */
const uint8ArrayToBase64 = (a) => {
    const dec = new TextDecoder();
    return buffer_1.Buffer.from(a).toString('base64');
};
/**
 * @internal
 */
const base64ToUint8Array = (a) => {
    return Uint8Array.from(buffer_1.Buffer.from(a, 'base64'));
};
/**
 * Basic wallet.
 */
class BasicWallet extends base_1.WalletBase {
    /**
     * Constructor.
     */
    constructor(keyPair) {
        super();
        this._keyPair = keyPair;
        this._sign(buffer_1.Buffer.from('test')); // to check that keypair works
    }
    /**
     * Generate a wallet using a random mnemonic.
     */
    static generateRandom() {
        return BasicWallet.fromMnemonic(exports.generateMnemonic());
    }
    /**
     * Get whether this class can deserialize the given wallet data.
     *
     * @return {boolean} true if can, false if cannot.
     */
    static canDeserialize(data) {
        return data.startsWith(SERIALIZATION_PREFIX);
    }
    /**
     * Load a wallet from previously serialized wallet data.
     *
     * @throws {Error} If loading fails.
     */
    static fromSerialized(data) {
        try {
            if (!data.startsWith(SERIALIZATION_PREFIX)) {
                throw new Error('Bad serialized data');
            }
            const ret = JSON.parse(data.substr(SERIALIZATION_PREFIX.length));
            const keyPair = {
                privateKey: base64ToUint8Array(ret.privateKey),
                publicKey: base64ToUint8Array(ret.publicKey),
            };
            return new BasicWallet(keyPair);
        }
        catch (err) {
            throw new Error(`Error restoring from serialized data: ${err.message}`);
        }
    }
    /**
     * Load a wallet using from a mnemonic.
     *
     * @throws {Error} If loading fails.
     */
    static fromMnemonic(mnemonic) {
        mnemonic = mnemonic.trim();
        try {
            const keyPair = ed25519Keypair_1.generatePairFromMnemonic(mnemonic);
            return new BasicWallet(keyPair);
        }
        catch (err) {
            throw new Error(`Error deriving from mnemonic: ${err.message}`);
        }
    }
    /**
     * Load a wallet from a JSON key file string.
     *
     * @throws {Error} If loading fails.
     */
    static fromJsonKeyFileString(json, password) {
        try {
            const keyFile = JSON.parse(json.trim());
            const { kdfparams } = keyFile.crypto;
            const derivedKey = keyDerivation_1.generateDerivedKey(buffer_1.Buffer.from(password), buffer_1.Buffer.from(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);
            const ciphertext = buffer_1.Buffer.from(keyFile.crypto.ciphertext, 'hex');
            const mac = crypto_1.default.createHmac('sha256', derivedKey.slice(16, 32))
                .update(ciphertext)
                .digest();
            if (mac.toString('hex') !== keyFile.crypto.mac) {
                throw new Error('MAC mismatch, possibly wrong password');
            }
            const decipher = crypto_1.default.createDecipheriv(keyFile.crypto.cipher, derivedKey.slice(0, 16), buffer_1.Buffer.from(keyFile.crypto.cipherparams.iv, 'hex'));
            let seed = buffer_1.Buffer.concat([decipher.update(ciphertext), decipher.final()]);
            while (seed.length < 32) {
                let nullBuff = buffer_1.Buffer.from([0x00]);
                seed = buffer_1.Buffer.concat([nullBuff, seed]);
            }
            const keyPair = {
                privateKey: seed,
                publicKey: ed25519Keypair_1.generatePublicKey(seed),
            };
            return new BasicWallet(keyPair);
        }
        catch (err) {
            throw new Error(`Error deriving from JSON: ${err.message}`);
        }
    }
    /**
     * Load a wallet from a PEM file string.
     *
     * @throws {Error} If loading fails.
     */
    static fromPemFileString(pem) {
        try {
            const matches = PEM_REGEX.exec(pem.trim());
            const match = (matches ? matches[1] : '').trim();
            if (match) {
                const bytes = buffer_1.Buffer.from(buffer_1.Buffer.from(match, 'base64').toString(), 'hex');
                const uint8array = new Uint8Array(bytes);
                const keyPair = {
                    privateKey: uint8array,
                    publicKey: ed25519Keypair_1.generatePublicKey(uint8array),
                };
                return new BasicWallet(keyPair);
            }
            else {
                throw new Error('No PEM found');
            }
        }
        catch (err) {
            throw new Error(`Error deriving from PEM: ${err.message}`);
        }
    }
    _sign(rawTx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._keyPair.privateKey) {
                throw new Error('Key pair corruption, cannot sign message');
            }
            const sig = ed25519Keypair_1.sign(rawTx, this._keyPair.privateKey);
            return buffer_1.Buffer.from(sig).toString('hex');
        });
    }
    _getAddress() {
        const words = bech32_1.default.toWords(buffer_1.Buffer.from(this._keyPair.publicKey));
        return bech32_1.default.encode('erd', words);
    }
    serialize() {
        const kps = {
            privateKey: uint8ArrayToBase64(this._keyPair.privateKey),
            publicKey: uint8ArrayToBase64(this._keyPair.publicKey),
        };
        return `${SERIALIZATION_PREFIX}${JSON.stringify(kps)}`;
    }
}
exports.BasicWallet = BasicWallet;
